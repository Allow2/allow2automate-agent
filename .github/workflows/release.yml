name: Release

on:
  push:
    tags:
      - 'v*.*.*'

permissions:
  contents: write

jobs:
  build-and-sign:
    name: Build and Sign Installers
    strategy:
      matrix:
        include:
          - os: windows-latest
            platform: windows
            ext: msi
          - os: macos-latest
            platform: macos
            ext: pkg
          - os: ubuntu-latest
            platform: linux
            ext: deb,rpm

    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Generate lock file if missing
        shell: bash
        run: |
          if [ ! -f package-lock.json ]; then
            npm install --package-lock-only
          fi

      - name: Cache npm dependencies
        uses: actions/cache@v3
        with:
          path: ~/.npm
          key: ${{ runner.os }}-npm-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-npm-

      - name: Install dependencies
        run: npm ci
        timeout-minutes: 15

      - name: Get version from tag
        id: version
        shell: bash
        run: echo "VERSION=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT

      # Windows Build and Sign
      #- name: Build Windows executable
      #  if: matrix.platform == 'windows'
      #  shell: bash
      #  run: bash installers/windows/build.sh

      #- name: Sign Windows executable
      #  if: matrix.platform == 'windows'
      #  env:
      #    WINDOWS_CERT_BASE64: ${{ secrets.WINDOWS_CERT_BASE64 }}
      #  shell: pwsh
      #  run: |
      #    if ([string]::IsNullOrEmpty($env:WINDOWS_CERT_BASE64)) {
      #      Write-Host "Skipping code signing - WINDOWS_CERT_BASE64 not set"
      #      exit 0
      #    }

      #    [System.Convert]::FromBase64String($env:WINDOWS_CERT_BASE64) | Set-Content -Path certificate.pfx -Encoding Byte
      #    $exe = Get-ChildItem -Path installers/windows/dist/*.exe | Select-Object -First 1
      #    & "C:\Program Files (x86)\Windows Kits\10\bin\10.0.22621.0\x64\signtool.exe" sign /f certificate.pfx /p "${{ secrets.WINDOWS_CERT_PASSWORD }}" /tr http://timestamp.digicert.com /td sha256 /fd sha256 $exe.FullName
      #    Remove-Item certificate.pfx

      # macOS Build and Sign
      - name: Import Apple certificate
        if: matrix.platform == 'macos'
        env:
          APPLE_CERT_BASE64: ${{ secrets.APPLE_CERT_BASE64 }}
        run: |
          if [ -z "$APPLE_CERT_BASE64" ]; then
            echo "Skipping certificate import - APPLE_CERT_BASE64 not set"
            exit 0
          fi

          # Decode certificate
          echo "${{ secrets.APPLE_CERT_BASE64 }}" | base64 -d > certificate.p12

          # Create temporary keychain
          security create-keychain -p actions temp.keychain
          security set-keychain-settings -lut 21600 temp.keychain
          security default-keychain -s temp.keychain
          security unlock-keychain -p actions temp.keychain

          # Import certificate with -A flag (allow any application access)
          security import certificate.p12 \
            -k temp.keychain \
            -P "${{ secrets.APPLE_CERT_PASSWORD }}" \
            -A \
            -t cert \
            -f pkcs12

          # CRITICAL: Set partition list with codesign: partition
          security set-key-partition-list \
            -S apple-tool:,apple:,codesign: \
            -s \
            -k actions \
            temp.keychain

          # Add to keychain search list
          security list-keychain -d user -s temp.keychain login.keychain

          # Verify identities are available
          echo "=== Verifying imported identities ==="
          security find-identity -v temp.keychain

          # Cleanup
          rm certificate.p12

      - name: Build macOS PKG (with binary codesigning)
        if: matrix.platform == 'macos'
        env:
          APPLE_DEVELOPER_ID: ${{ secrets.APPLE_DEVELOPER_ID }}
          VERSION: ${{ steps.version.outputs.VERSION }}
        run: bash installers/macos/build.sh

      - name: Sign and notarize macOS PKG
        if: matrix.platform == 'macos'
        env:
          APPLE_DEVELOPER_ID: ${{ secrets.APPLE_DEVELOPER_ID }}
        run: |
          if [ -z "$APPLE_DEVELOPER_ID" ]; then
            echo "Skipping signing/notarization - APPLE_DEVELOPER_ID not set"
            exit 0
          fi

          echo "=== Verifying Binary Signature Before PKG Signing ==="
          # Check if the binary was signed in the build script
          BINARY="installers/macos/build/payload/usr/local/bin/allow2automate-agent"
          if [ -f "$BINARY" ]; then
            echo "Checking binary signature..."
            if codesign --verify --verbose=2 "$BINARY" 2>&1; then
              echo "✅ Binary is signed"
              codesign --display --verbose=2 "$BINARY" 2>&1 | grep "Authority\|Identifier\|TeamIdentifier" || true
            else
              echo "❌ WARNING: Binary is NOT signed or signature is invalid!"
              echo "This will cause notarization to fail."
            fi
          else
            echo "❌ WARNING: Binary not found at expected location: $BINARY"
          fi

          echo "=== Signing PKG ==="
          PKG=$(find installers/macos/dist -name "*.pkg" | head -n 1)
          echo "PKG to sign: $PKG"

          productsign --sign "${{ secrets.APPLE_DEVELOPER_ID }}" "$PKG" "${PKG%.pkg}-signed.pkg"
          mv "${PKG%.pkg}-signed.pkg" "$PKG"

          echo "✅ PKG signed successfully"

          echo "=== Submitting for Notarization ==="
          SUBMISSION_OUTPUT=$(xcrun notarytool submit "$PKG" \
            --apple-id "${{ secrets.APPLE_ID }}" \
            --password "${{ secrets.APPLE_NOTARIZATION_PASSWORD }}" \
            --team-id "${{ secrets.APPLE_TEAM_ID }}" \
            --wait 2>&1)

          echo "$SUBMISSION_OUTPUT"

          # Extract submission ID for log retrieval
          SUBMISSION_ID=$(echo "$SUBMISSION_OUTPUT" | grep "id:" | head -1 | awk '{print $2}')
          echo "Submission ID: $SUBMISSION_ID"

          # Check if notarization succeeded
          if echo "$SUBMISSION_OUTPUT" | grep -q "status: Accepted"; then
            echo "✅ Notarization accepted"
            xcrun stapler staple "$PKG"
            echo "✅ Stapled notarization ticket"
          else
            echo "❌ Notarization failed or was rejected"
            echo "Fetching detailed notarization log..."

            # Get the detailed log
            xcrun notarytool log "$SUBMISSION_ID" \
              --apple-id "${{ secrets.APPLE_ID }}" \
              --password "${{ secrets.APPLE_NOTARIZATION_PASSWORD }}" \
              --team-id "${{ secrets.APPLE_TEAM_ID }}" || true

            exit 1
          fi

      # Linux Build and Sign
      - name: Install fpm (Linux)
        if: matrix.platform == 'linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y ruby ruby-dev rubygems build-essential rpm
          sudo gem install --no-document fpm

      - name: Build Linux packages (DEB and RPM)
        if: matrix.platform == 'linux'
        env:
          VERSION: ${{ steps.version.outputs.VERSION }}
        run: bash installers/linux/build.sh

      - name: Import GPG key
        if: matrix.platform == 'linux'
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        run: |
          if [ -z "$GPG_PRIVATE_KEY" ]; then
            echo "Skipping GPG import - GPG_PRIVATE_KEY not set"
            exit 0
          fi

          echo "=== Importing GPG Key ==="
          # Import the key
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --import

          # Configure GPG agent
          echo "allow-preset-passphrase" > ~/.gnupg/gpg-agent.conf
          gpg-connect-agent reloadagent /bye

          # Verify what was imported (GitHub-safe - redact last 4 chars of key IDs)
          echo "=== Verifying GPG Keys ==="
          echo "Public keys imported:"
          gpg --list-keys --keyid-format LONG | grep -A 1 "pub" | sed 's/\([A-F0-9]\{12\}\)[A-F0-9]\{4\}/\1XXXX/g'

          echo "Secret keys imported:"
          gpg --list-secret-keys --keyid-format LONG | grep -A 1 "sec" | sed 's/\([A-F0-9]\{12\}\)[A-F0-9]\{4\}/\1XXXX/g'

          # Count secret keys
          SECRET_COUNT=$(gpg --list-secret-keys --keyid-format LONG 2>/dev/null | grep -c "^sec" || echo "0")
          echo "Total secret keys available: $SECRET_COUNT"

          if [ "$SECRET_COUNT" -eq 0 ]; then
            echo "❌ ERROR: No secret keys were imported!"
            echo "The GPG_PRIVATE_KEY secret may only contain the public key."
            echo "To export your private key properly, use:"
            echo "  gpg --export-secret-keys --armor YOUR_KEY_ID"
            exit 1
          fi

          echo "✅ Secret key imported successfully"

      - name: Sign Linux packages
        if: matrix.platform == 'linux'
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        run: |
          if [ -z "$GPG_PRIVATE_KEY" ]; then
            echo "Skipping package signing - GPG_PRIVATE_KEY not set"
            exit 0
          fi

          echo "=== Signing Linux Packages ==="
          # Redact GPG_KEY_ID for display (show first 12 chars, hide last 4)
          REDACTED_KEY_ID="${{ secrets.GPG_KEY_ID }}"
          REDACTED_KEY_ID="${REDACTED_KEY_ID:0:12}XXXX"
          echo "Using GPG Key ID (redacted): $REDACTED_KEY_ID"

          # Verify the key exists before attempting to sign
          if ! gpg --list-secret-keys "${{ secrets.GPG_KEY_ID }}" >/dev/null 2>&1; then
            echo "❌ ERROR: Secret key $REDACTED_KEY_ID not found!"
            echo "Available secret keys:"
            gpg --list-secret-keys --keyid-format LONG | sed 's/\([A-F0-9]\{12\}\)[A-F0-9]\{4\}/\1XXXX/g'
            exit 1
          fi

          # Sign each package
          for pkg in installers/linux/dist/*.deb installers/linux/dist/*.rpm; do
            if [ -f "$pkg" ]; then
              echo "Signing: $(basename $pkg)"
              echo "${{ secrets.GPG_PASSPHRASE }}" | gpg --batch --yes --passphrase-fd 0 \
                --pinentry-mode loopback -u "${{ secrets.GPG_KEY_ID }}" \
                --detach-sign --armor "$pkg"

              # Verify signature was created
              if [ -f "$pkg.asc" ]; then
                echo "✅ Signature created: $(basename $pkg).asc"
              else
                echo "❌ ERROR: Signature file not created for $(basename $pkg)"
                exit 1
              fi
            fi
          done

          echo "✅ All packages signed successfully"

      # Upload artifacts
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: installer-${{ matrix.platform }}
          path: |
            installers/windows/dist/*.exe
            installers/macos/dist/*.pkg
            installers/linux/dist/*.deb
            installers/linux/dist/*.rpm
            installers/**/*.asc
          retention-days: 90

  create-release:
    name: Create GitHub Release
    needs: build-and-sign
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Get version from tag
        id: version
        run: echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

      - name: Rename installers with version
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          mkdir -p release-files

          # Windows
          if [ -f artifacts/installer-windows/*.exe ]; then
            EXE=$(find artifacts/installer-windows -name "*.exe" | head -n 1)
            cp "$EXE" "release-files/allow2automate-agent-win-x64-${VERSION}.exe"
          fi

          # macOS
          if [ -f artifacts/installer-macos/*.pkg ]; then
            PKG=$(find artifacts/installer-macos -name "*.pkg" | head -n 1)
            cp "$PKG" "release-files/allow2automate-agent-darwin-x64-${VERSION}.pkg"
          fi

          # Linux DEB
          if [ -f artifacts/installer-linux/*.deb ]; then
            DEB=$(find artifacts/installer-linux -name "*.deb" | head -n 1)
            cp "$DEB" "release-files/allow2automate-agent-linux-amd64-${VERSION}.deb"
          fi

          # Linux RPM
          if [ -f artifacts/installer-linux/*.rpm ]; then
            RPM=$(find artifacts/installer-linux -name "*.rpm" | head -n 1)
            cp "$RPM" "release-files/allow2automate-agent-linux-x86_64-${VERSION}.rpm"
          fi

          # Copy signature files
          cp artifacts/installer-*/*.asc release-files/ 2>/dev/null || true

      - name: Generate checksums
        run: |
          cd release-files
          sha256sum * > checksums.txt
          cat checksums.txt

      - name: Create release metadata
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          cat > release-files/release-metadata.json << 'EOF'
          {
            "version": "$VERSION",
            "released": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "platforms": ["windows", "macos", "linux"],
            "checksums": {
          EOF

          cd release-files
          first=true
          for file in *.exe *.pkg *.deb *.rpm; do
            if [ -f "$file" ]; then
              hash=$(sha256sum "$file" | awk '{print $1}')
              if [ "$first" = true ]; then
                first=false
              else
                echo "," >> release-metadata.json
              fi
              echo "      \"$file\": \"$hash\"" >> release-metadata.json
            fi
          done

          cat >> release-metadata.json << 'EOF'
            }
          }
          EOF

      - name: Generate changelog
        id: changelog
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")

          if [ -z "$PREV_TAG" ]; then
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" HEAD)
          else
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" ${PREV_TAG}..HEAD)
          fi

          cat > release-notes.md << EOF
          ## Allow2 Automate Agent ${VERSION}

          ### Installation Instructions

          #### Windows
          1. Download \`allow2automate-agent-win-x64-${VERSION}.exe\`
          2. Run the executable with administrator privileges
          3. The agent service will start automatically

          #### macOS
          1. Download \`allow2automate-agent-darwin-x64-${VERSION}.pkg\`
          2. Open the package and follow the installer
          3. The agent will start automatically as a LaunchDaemon

          #### Linux (DEB)
          \`\`\`bash
          wget https://github.com/${{ github.repository }}/releases/download/${VERSION}/allow2automate-agent-linux-amd64-${VERSION}.deb
          sudo dpkg -i allow2automate-agent-linux-amd64-${VERSION}.deb
          sudo systemctl start allow2automate-agent
          \`\`\`

          #### Linux (RPM)
          \`\`\`bash
          wget https://github.com/${{ github.repository }}/releases/download/${VERSION}/allow2automate-agent-linux-x86_64-${VERSION}.rpm
          sudo rpm -i allow2automate-agent-linux-x86_64-${VERSION}.rpm
          sudo systemctl start allow2automate-agent
          \`\`\`

          ### Verification

          All installers are signed and include SHA256 checksums in \`checksums.txt\`.

          To verify your download:
          \`\`\`bash
          sha256sum -c checksums.txt
          \`\`\`

          ### Changes

          ${CHANGELOG}

          ### Platform Support

          - Windows 10/11 (x64)
          - macOS 11+ (x64, ARM64)
          - Linux (DEB/RPM, x64)

          ### Requirements

          - Node.js 18.0.0 or higher (bundled in installers)
          - Internet connection for Allow2 API communication

          ---

          **Full Changelog**: https://github.com/${{ github.repository }}/compare/${PREV_TAG}...${VERSION}
          EOF

          cat release-notes.md

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: release-files/*
          body_path: release-notes.md
          draft: false
          prerelease: false
          generate_release_notes: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Release summary
        run: |
          echo "## Release Created Successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Version: ${{ steps.version.outputs.VERSION }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Artifacts" >> $GITHUB_STEP_SUMMARY
          ls -lh release-files/ >> $GITHUB_STEP_SUMMARY
