name: Release

on:
  push:
    tags:
      - 'v*.*.*'

permissions:
  contents: write
  id-token: write  # Required for Azure OIDC authentication

jobs:
  build-and-sign:
    name: Build and Sign Installers
    strategy:
      matrix:
        include:
          - os: windows-latest
            platform: windows
            ext: msi
          - os: macos-latest
            platform: macos
            ext: pkg
          - os: ubuntu-latest
            platform: linux
            ext: deb,rpm

    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Cache npm dependencies
        uses: actions/cache@v3
        with:
          path: ~/.npm
          key: ${{ runner.os }}-npm-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-npm-

      - name: Install dependencies
        run: npm ci
        timeout-minutes: 15

      - name: Get version from tag
        id: version
        shell: bash
        run: echo "VERSION=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT

      # Windows Build and Sign
      - name: Build Windows executables
        if: matrix.platform == 'windows'
        shell: bash
        env:
          VERSION: ${{ steps.version.outputs.VERSION }}
        run: bash installers/windows/build.sh

      - name: Azure Login for Code Signing
        if: matrix.platform == 'windows'
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Sign Windows executables with Azure Trusted Signing
        if: matrix.platform == 'windows'
        uses: azure/trusted-signing-action@v0.5.0
        with:
          endpoint: https://eus.codesigning.azure.net/
          trusted-signing-account-name: Allow2
          certificate-profile-name: Allow2-Dev-Signing
          files-folder: ${{ github.workspace }}/dist
          files-folder-filter: exe
          file-digest: SHA256
          timestamp-rfc3161: http://timestamp.acs.microsoft.com
          timestamp-digest: SHA256

      - name: Install Inno Setup
        if: matrix.platform == 'windows'
        shell: pwsh
        run: choco install innosetup -y

      - name: Build Windows installer with Inno Setup
        if: matrix.platform == 'windows'
        shell: pwsh
        env:
          VERSION: ${{ steps.version.outputs.VERSION }}
        run: |
          Write-Host "Building Windows installer with Inno Setup..."

          # Run Inno Setup compiler
          & "C:\Program Files (x86)\Inno Setup 6\ISCC.exe" `
            "/DAppVersion=$env:VERSION" `
            "/DSourceDir=${{ github.workspace }}\dist" `
            "installers\windows\setup.iss"

          if ($LASTEXITCODE -ne 0) {
            Write-Host "Inno Setup compilation failed"
            exit 1
          }

          # Show what was built
          Write-Host "=== Built installer ==="
          Get-ChildItem -Path "installers\windows\dist\*.exe" | ForEach-Object {
            Write-Host "  $($_.Name) ($([math]::Round($_.Length / 1MB, 2)) MB)"
          }

      - name: Sign Windows installer with Azure Trusted Signing
        if: matrix.platform == 'windows'
        uses: azure/trusted-signing-action@v0.5.0
        with:
          endpoint: https://eus.codesigning.azure.net/
          trusted-signing-account-name: Allow2
          certificate-profile-name: Allow2-Dev-Signing
          files-folder: ${{ github.workspace }}/installers/windows/dist
          files-folder-filter: exe
          file-digest: SHA256
          timestamp-rfc3161: http://timestamp.acs.microsoft.com
          timestamp-digest: SHA256

      - name: Verify Windows signatures
        if: matrix.platform == 'windows'
        shell: pwsh
        run: |
          Write-Host "=== Verifying code signatures ==="

          # Find signtool
          $signtool = Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits\10\bin" -Recurse -Filter "signtool.exe" |
            Where-Object { $_.FullName -match "x64" } |
            Sort-Object { [version]($_.FullName -replace '.*\\(\d+\.\d+\.\d+\.\d+)\\.*', '$1') } -Descending |
            Select-Object -First 1 -ExpandProperty FullName

          Write-Host "Using signtool: $signtool"

          # Verify main binary signatures
          Get-ChildItem -Path "dist\*.exe" | ForEach-Object {
            Write-Host "Verifying: $($_.Name)"
            & $signtool verify /pa $_.FullName
            if ($LASTEXITCODE -eq 0) {
              Write-Host "  Signature valid"
            } else {
              Write-Host "  WARNING: Signature verification failed"
            }
          }

          # Verify installer signature
          Get-ChildItem -Path "installers\windows\dist\*.exe" | ForEach-Object {
            Write-Host "Verifying installer: $($_.Name)"
            & $signtool verify /pa $_.FullName
            if ($LASTEXITCODE -eq 0) {
              Write-Host "  Signature valid"
            } else {
              Write-Host "  WARNING: Installer signature verification failed"
            }
          }

      # macOS Build and Sign
      - name: Import Apple certificates
        if: matrix.platform == 'macos'
        env:
          APPLE_APP_CERT_BASE64: ${{ secrets.APPLE_APP_CERT_BASE64 }}
          APPLE_INSTALLER_CERT_BASE64: ${{ secrets.APPLE_INSTALLER_CERT_BASE64 }}
        run: |
          # Check if certificates are provided
          if [ -z "$APPLE_APP_CERT_BASE64" ] && [ -z "$APPLE_INSTALLER_CERT_BASE64" ]; then
            echo "⚠️  No certificates provided - skipping code signing"
            echo "To enable code signing, set these GitHub secrets:"
            echo "  - APPLE_APP_CERT_BASE64 (Developer ID Application)"
            echo "  - APPLE_INSTALLER_CERT_BASE64 (Developer ID Installer)"
            exit 0
          fi

          # Create temporary keychain
          KEYCHAIN_PATH="$HOME/Library/Keychains/temp.keychain-db"
          KEYCHAIN_PASSWORD="actions"

          security create-keychain -p "$KEYCHAIN_PASSWORD" temp.keychain
          security set-keychain-settings -lut 21600 temp.keychain
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" temp.keychain

          # Import Application certificate (for signing binaries)
          if [ -n "$APPLE_APP_CERT_BASE64" ]; then
            echo "=== Importing Developer ID Application Certificate ==="
            echo "${{ secrets.APPLE_APP_CERT_BASE64 }}" | base64 -d > app_cert.p12

            if [ ! -f app_cert.p12 ] || [ ! -s app_cert.p12 ]; then
              echo "❌ ERROR: app_cert.p12 file is missing or empty"
              exit 1
            fi
            echo "✅ Application certificate file created (size: $(wc -c < app_cert.p12) bytes)"

            # Import Application certificate
            security import app_cert.p12 \
              -k temp.keychain \
              -P "${{ secrets.APPLE_CERT_PASSWORD }}" \
              -A

            rm app_cert.p12

            # Verify Application certificate
            APP_CERT_INFO=$(security find-certificate -a -p temp.keychain | openssl x509 -noout -subject -ext extendedKeyUsage 2>/dev/null || echo "")
            if echo "$APP_CERT_INFO" | grep -q "Developer ID Application"; then
              echo "✅ Developer ID Application certificate imported"
            else
              echo "⚠️  WARNING: Application certificate might not be correct type"
            fi
          else
            echo "⚠️  APPLE_APP_CERT_BASE64 not set - binary will not be signed"
          fi

          # Import Installer certificate (for signing PKG)
          if [ -n "$APPLE_INSTALLER_CERT_BASE64" ]; then
            echo ""
            echo "=== Importing Developer ID Installer Certificate ==="
            echo "${{ secrets.APPLE_INSTALLER_CERT_BASE64 }}" | base64 -d > installer_cert.p12

            if [ ! -f installer_cert.p12 ] || [ ! -s installer_cert.p12 ]; then
              echo "❌ ERROR: installer_cert.p12 file is missing or empty"
              exit 1
            fi
            echo "✅ Installer certificate file created (size: $(wc -c < installer_cert.p12) bytes)"

            # Import Installer certificate
            security import installer_cert.p12 \
              -k temp.keychain \
              -P "${{ secrets.APPLE_CERT_PASSWORD }}" \
              -A

            rm installer_cert.p12

            # Verify Installer certificate
            INSTALLER_CERT_INFO=$(security find-certificate -a -p temp.keychain | openssl x509 -noout -subject -ext extendedKeyUsage 2>/dev/null || echo "")
            if echo "$INSTALLER_CERT_INFO" | grep -q "Developer ID Installer"; then
              echo "✅ Developer ID Installer certificate imported"
            else
              echo "⚠️  WARNING: Installer certificate might not be correct type"
            fi
          else
            echo "⚠️  APPLE_INSTALLER_CERT_BASE64 not set - PKG will not be signed"
          fi

          # Set partition list to allow codesign/productsign access
          echo ""
          echo "=== Configuring Keychain Access ==="
          security set-keychain-settings -lut 21600 temp.keychain
          security default-keychain -s temp.keychain

          security set-key-partition-list \
            -S apple-tool:,apple:,codesign:,productsign: \
            -s \
            -k "$KEYCHAIN_PASSWORD" \
            temp.keychain

          # Add to keychain search list
          security list-keychains -d user -s \
            "$KEYCHAIN_PATH" \
            "$HOME/Library/Keychains/login.keychain-db"

          # Verify all identities
          echo ""
          echo "=== Final Identity Verification ==="

          echo "All identities in keychain (no filter):"
          security find-identity -v temp.keychain | sed 's/\("[^"]*"\)/"***"/g'

          echo ""
          echo "Code signing identities:"
          security find-identity -v -p codesigning temp.keychain | sed 's/\("[^"]*"\)/"***"/g'

          echo ""
          echo "Checking certificate details..."

          # Get all certificates and check their extended key usage
          CERT_COUNT=$(security find-certificate -a temp.keychain | grep -c "BEGIN CERTIFICATE" || echo "0")
          echo "Total certificates in keychain: $CERT_COUNT"

          # Check each certificate's purpose
          security find-certificate -a -p temp.keychain | while read -r line; do
            if [[ "$line" == "-----BEGIN CERTIFICATE-----" ]]; then
              cert_data="$line"
            elif [[ "$line" == "-----END CERTIFICATE-----" ]]; then
              cert_data+=$'\n'"$line"
              echo "$cert_data" | openssl x509 -noout -subject -ext extendedKeyUsage 2>/dev/null || true
              echo "---"
              cert_data=""
            else
              cert_data+=$'\n'"$line"
            fi
          done

          # Count identities by searching all identities (no policy filter)
          # Note: -p codesigning only shows Application certs, not Installer certs
          ALL_IDENTITIES=$(security find-identity -v temp.keychain 2>&1)
          APP_IDENTITY_COUNT=$(echo "$ALL_IDENTITIES" | grep -c "Developer ID Application" || echo "0")
          INSTALLER_IDENTITY_COUNT=$(echo "$ALL_IDENTITIES" | grep -c "Developer ID Installer" || echo "0")

          echo ""
          echo "Identity counts:"
          echo "  Application identities: $APP_IDENTITY_COUNT"
          echo "  Installer identities: $INSTALLER_IDENTITY_COUNT"

          if [ "$APP_IDENTITY_COUNT" -eq 0 ] && [ "$INSTALLER_IDENTITY_COUNT" -eq 0 ]; then
            echo ""
            echo "❌ ERROR: No valid signing identities found!"
            echo ""
            echo "Troubleshooting:"
            echo "1. Verify certificates were exported WITH private keys"
            echo "2. Check that both .p12 files contain 'Developer ID' certificates"
            echo "3. Ensure the password is correct"
            echo ""
            echo "To verify your .p12 files locally:"
            echo "  openssl pkcs12 -in app_cert.p12 -info -nodes"
            echo "  openssl pkcs12 -in installer_cert.p12 -info -nodes"
            exit 1
          fi

          echo "✅ Certificate import complete"

      - name: Build macOS PKG (with binary codesigning)
        if: matrix.platform == 'macos'
        env:
          APPLE_DEVELOPER_ID: ${{ secrets.APPLE_DEVELOPER_ID }}
          VERSION: ${{ steps.version.outputs.VERSION }}
        run: bash installers/macos/build.sh

      - name: Sign and notarize macOS PKG
        if: matrix.platform == 'macos'
        env:
          APPLE_INSTALLER_CERT_BASE64: ${{ secrets.APPLE_INSTALLER_CERT_BASE64 }}
        run: |
          if [ -z "$APPLE_INSTALLER_CERT_BASE64" ]; then
            echo "⚠️  APPLE_INSTALLER_CERT_BASE64 not set - skipping PKG signing"
            echo "PKG will be created but not signed or notarized"
            exit 0
          fi

          echo "=== Verifying Binary Signature Before PKG Signing ==="
          BINARY="installers/macos/build/payload/usr/local/bin/allow2automate-agent"
          if [ -f "$BINARY" ]; then
            echo "Checking binary signature..."
            if codesign --verify --verbose=2 "$BINARY" 2>&1; then
              echo "✅ Binary is signed"
              codesign --display --verbose=2 "$BINARY" 2>&1 | grep "Authority\|Identifier\|TeamIdentifier" || true
            else
              echo "⚠️  WARNING: Binary is NOT signed"
              echo "This may cause notarization to fail"
            fi
          else
            echo "❌ ERROR: Binary not found at $BINARY"
            exit 1
          fi

          echo ""
          echo "=== Signing PKG with Developer ID Installer ==="
          PKG=$(find installers/macos/dist -name "*.pkg" | head -n 1)

          if [ -z "$PKG" ]; then
            echo "❌ ERROR: No PKG file found in installers/macos/dist/"
            exit 1
          fi

          echo "PKG to sign: $PKG"

          # Find the Developer ID Installer identity
          echo "Searching for Developer ID Installer identity..."
          INSTALLER_IDENTITY=$(security find-identity -v -p codesigning temp.keychain 2>&1 | grep "Developer ID Installer" | head -1 | awk '{print $2}')

          if [ -z "$INSTALLER_IDENTITY" ]; then
            echo "⚠️  No 'Developer ID Installer' found by name"
            echo ""
            echo "Available identities in keychain:"
            security find-identity -v temp.keychain | sed 's/\("[^"]*"\)/"***"/g'

            echo ""
            echo "Checking if any identity can sign PKG files..."

            # Try to find any identity that might work
            # Sometimes the Installer cert doesn't show up with grep but exists
            ALL_IDENTITIES=$(security find-identity -v temp.keychain 2>&1 | grep -E '^\s+[0-9]+\)' | awk '{print $2}')

            for identity in $ALL_IDENTITIES; do
              echo "Testing identity: ${identity:0:8}...${identity: -4}"

              # Try to sign with this identity (test only)
              if productsign --sign "$identity" --keychain temp.keychain "$PKG" /tmp/test-sign.pkg 2>&1; then
                echo "✅ Found working identity: ${identity:0:8}...${identity: -4}"
                INSTALLER_IDENTITY="$identity"
                rm -f /tmp/test-sign.pkg
                break
              else
                echo "   Not suitable for PKG signing"
                rm -f /tmp/test-sign.pkg
              fi
            done

            if [ -z "$INSTALLER_IDENTITY" ]; then
              echo ""
              echo "❌ ERROR: No identity found that can sign PKG files"
              echo ""
              echo "This usually means:"
              echo "1. The APPLE_INSTALLER_CERT_BASE64 secret contains the wrong certificate"
              echo "2. The certificate was exported without its private key"
              echo "3. The certificate password is incorrect"
              echo ""
              echo "Please verify your installer certificate export:"
              echo "  security find-identity -v -p codesigning | grep Installer"
              echo "  security export -k login.keychain -t identities -f pkcs12 \\"
              echo "    -o installer_cert.p12 'Developer ID Installer: Your Company'"
              exit 1
            fi
          fi

          echo "Using installer identity: ${INSTALLER_IDENTITY:0:8}...${INSTALLER_IDENTITY: -4}"

          # Sign the PKG
          productsign --sign "$INSTALLER_IDENTITY" \
            --keychain temp.keychain \
            "$PKG" \
            "${PKG%.pkg}-signed.pkg"

          if [ ! -f "${PKG%.pkg}-signed.pkg" ]; then
            echo "❌ ERROR: PKG signing failed - signed file not created"
            exit 1
          fi

          mv "${PKG%.pkg}-signed.pkg" "$PKG"
          echo "✅ PKG signed successfully"

          # Verify PKG signature
          echo ""
          echo "=== Verifying PKG Signature ==="
          if pkgutil --check-signature "$PKG"; then
            echo "✅ PKG signature is valid"
          else
            echo "❌ ERROR: PKG signature verification failed"
            exit 1
          fi

          echo ""
          echo "=== Submitting for Notarization ==="

          # Check if notarization credentials are set
          if [ -z "${{ secrets.APPLE_ID }}" ] || [ -z "${{ secrets.APPLE_NOTARIZATION_PASSWORD }}" ] || [ -z "${{ secrets.APPLE_TEAM_ID }}" ]; then
            echo "⚠️  Notarization credentials not set - skipping notarization"
            echo "PKG is signed but not notarized"
            echo "To enable notarization, set these secrets:"
            echo "  - APPLE_ID"
            echo "  - APPLE_NOTARIZATION_PASSWORD (app-specific password)"
            echo "  - APPLE_TEAM_ID"
            exit 0
          fi

          SUBMISSION_OUTPUT=$(xcrun notarytool submit "$PKG" \
            --apple-id "${{ secrets.APPLE_ID }}" \
            --password "${{ secrets.APPLE_NOTARIZATION_PASSWORD }}" \
            --team-id "${{ secrets.APPLE_TEAM_ID }}" \
            --wait 2>&1)

          echo "$SUBMISSION_OUTPUT"

          # Extract submission ID for log retrieval
          SUBMISSION_ID=$(echo "$SUBMISSION_OUTPUT" | grep "id:" | head -1 | awk '{print $2}')
          echo "Submission ID: $SUBMISSION_ID"

          # Check if notarization succeeded
          if echo "$SUBMISSION_OUTPUT" | grep -q "status: Accepted"; then
            echo "✅ Notarization accepted"
            xcrun stapler staple "$PKG"
            echo "✅ Stapled notarization ticket to PKG"
          else
            echo "❌ Notarization failed or was rejected"
            echo ""
            echo "Fetching detailed notarization log..."
            xcrun notarytool log "$SUBMISSION_ID" \
              --apple-id "${{ secrets.APPLE_ID }}" \
              --password "${{ secrets.APPLE_NOTARIZATION_PASSWORD }}" \
              --team-id "${{ secrets.APPLE_TEAM_ID }}" || true

            exit 1
          fi

      # Linux Build and Sign
      - name: Install fpm (Linux)
        if: matrix.platform == 'linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y ruby ruby-dev rubygems build-essential rpm
          sudo gem install --no-document fpm

      - name: Build Linux packages (DEB and RPM)
        if: matrix.platform == 'linux'
        env:
          VERSION: ${{ steps.version.outputs.VERSION }}
        run: bash installers/linux/build.sh

      - name: Import GPG key
        if: matrix.platform == 'linux'
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        run: |
          if [ -z "$GPG_PRIVATE_KEY" ]; then
            echo "Skipping GPG import - GPG_PRIVATE_KEY not set"
            exit 0
          fi

          echo "=== Importing GPG Key ==="
          # Import the key
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --import

          # Configure GPG agent
          echo "allow-preset-passphrase" > ~/.gnupg/gpg-agent.conf
          gpg-connect-agent reloadagent /bye

          # Verify what was imported (GitHub-safe - redact last 4 chars of key IDs)
          echo "=== Verifying GPG Keys ==="
          echo "Public keys imported:"
          gpg --list-keys --keyid-format LONG | grep -A 1 "pub" | sed 's/\([A-F0-9]\{12\}\)[A-F0-9]\{4\}/\1XXXX/g'

          echo "Secret keys imported:"
          gpg --list-secret-keys --keyid-format LONG | grep -A 1 "sec" | sed 's/\([A-F0-9]\{12\}\)[A-F0-9]\{4\}/\1XXXX/g'

          # Count secret keys
          SECRET_COUNT=$(gpg --list-secret-keys --keyid-format LONG 2>/dev/null | grep -c "^sec" || echo "0")
          echo "Total secret keys available: $SECRET_COUNT"

          if [ "$SECRET_COUNT" -eq 0 ]; then
            echo "❌ ERROR: No secret keys were imported!"
            echo "The GPG_PRIVATE_KEY secret may only contain the public key."
            echo "To export your private key properly, use:"
            echo "  gpg --export-secret-keys --armor YOUR_KEY_ID"
            exit 1
          fi

          echo "✅ Secret key imported successfully"

      - name: Sign Linux packages
        if: matrix.platform == 'linux'
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        run: |
          if [ -z "$GPG_PRIVATE_KEY" ]; then
            echo "Skipping package signing - GPG_PRIVATE_KEY not set"
            exit 0
          fi

          echo "=== Signing Linux Packages ==="
          # Redact GPG_KEY_ID for display (show first 12 chars, hide last 4)
          REDACTED_KEY_ID="${{ secrets.GPG_KEY_ID }}"
          REDACTED_KEY_ID="${REDACTED_KEY_ID:0:12}XXXX"
          echo "Using GPG Key ID (redacted): $REDACTED_KEY_ID"

          # Verify the key exists before attempting to sign
          if ! gpg --list-secret-keys "${{ secrets.GPG_KEY_ID }}" >/dev/null 2>&1; then
            echo "❌ ERROR: Secret key $REDACTED_KEY_ID not found!"
            echo "Available secret keys:"
            gpg --list-secret-keys --keyid-format LONG | sed 's/\([A-F0-9]\{12\}\)[A-F0-9]\{4\}/\1XXXX/g'
            exit 1
          fi

          # Sign each package
          for pkg in installers/linux/dist/*.deb installers/linux/dist/*.rpm; do
            if [ -f "$pkg" ]; then
              echo "Signing: $(basename $pkg)"
              echo "${{ secrets.GPG_PASSPHRASE }}" | gpg --batch --yes --passphrase-fd 0 \
                --pinentry-mode loopback -u "${{ secrets.GPG_KEY_ID }}" \
                --detach-sign --armor "$pkg"

              # Verify signature was created
              if [ -f "$pkg.asc" ]; then
                echo "✅ Signature created: $(basename $pkg).asc"
              else
                echo "❌ ERROR: Signature file not created for $(basename $pkg)"
                exit 1
              fi
            fi
          done

          echo "✅ All packages signed successfully"

      # Upload artifacts
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: installer-${{ matrix.platform }}
          path: |
            installers/windows/dist/*.exe
            installers/macos/dist/*.pkg
            installers/linux/dist/*.deb
            installers/linux/dist/*.rpm
            installers/**/*.asc
          retention-days: 90

  create-release:
    name: Create GitHub Release
    needs: build-and-sign
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Get version from tag
        id: version
        run: echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

      - name: Rename installers with version
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          mkdir -p release-files

          # Debug: Show artifact structure
          echo "=== Artifact directory structure ==="
          ls -laR artifacts/

          # Windows - prefer the setup installer, fall back to raw exe
          WIN_INSTALLER=$(find artifacts/installer-windows -name "*setup*.exe" 2>/dev/null | head -n 1)
          if [ -z "$WIN_INSTALLER" ]; then
            WIN_INSTALLER=$(find artifacts/installer-windows -name "*.exe" 2>/dev/null | head -n 1)
          fi
          if [ -n "$WIN_INSTALLER" ]; then
            cp "$WIN_INSTALLER" "release-files/allow2automate-agent-win-x64-${VERSION}-setup.exe"
          fi

          # macOS
          find artifacts/installer-macos -name "*.pkg" 2>/dev/null | head -n 1 | xargs -I {} cp {} "release-files/allow2automate-agent-darwin-x64-${VERSION}.pkg"

          # Linux DEB
          find artifacts/installer-linux -name "*.deb" 2>/dev/null | head -n 1 | xargs -I {} cp {} "release-files/allow2automate-agent-linux-amd64-${VERSION}.deb"

          # Linux RPM
          find artifacts/installer-linux -name "*.rpm" 2>/dev/null | head -n 1 | xargs -I {} cp {} "release-files/allow2automate-agent-linux-x86_64-${VERSION}.rpm"

          # Copy signature files
          find artifacts -name "*.asc" -exec cp {} release-files/ \; 2>/dev/null || true

          # Copy uninstall scripts
          cp installers/macos/uninstall.sh "release-files/allow2automate-agent-macos-uninstall.sh"
          cp installers/linux/uninstall.sh "release-files/allow2automate-agent-linux-uninstall.sh"
          cp installers/windows/uninstall.bat "release-files/allow2automate-agent-windows-uninstall.bat"

          # Show what we copied
          echo "=== Files in release-files directory ==="
          ls -lh release-files/

      - name: Generate checksums
        run: |
          cd release-files
          sha256sum * > checksums.txt
          cat checksums.txt

      - name: Create release metadata
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          cat > release-files/release-metadata.json << 'EOF'
          {
            "version": "$VERSION",
            "released": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "platforms": ["windows", "macos", "linux"],
            "checksums": {
          EOF

          cd release-files
          first=true
          for file in *.exe *.pkg *.deb *.rpm; do
            if [ -f "$file" ]; then
              hash=$(sha256sum "$file" | awk '{print $1}')
              if [ "$first" = true ]; then
                first=false
              else
                echo "," >> release-metadata.json
              fi
              echo "      \"$file\": \"$hash\"" >> release-metadata.json
            fi
          done

          cat >> release-metadata.json << 'EOF'
            }
          }
          EOF

      - name: Generate changelog
        id: changelog
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")

          if [ -z "$PREV_TAG" ]; then
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" HEAD)
          else
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" ${PREV_TAG}..HEAD)
          fi

          cat > release-notes.md << EOF
          ## Allow2 Automate Agent ${VERSION}

          ### Installation Instructions

          #### Windows
          1. Download \`allow2automate-agent-win-x64-${VERSION}-setup.exe\`
          2. (Optional) Place your \`config.json\` file in the same folder as the installer
          3. Run the installer - it will auto-detect the config file or prompt you to browse for one
          4. Follow the installation wizard
          5. The agent service will start automatically

          #### macOS
          1. Download \`allow2automate-agent-darwin-x64-${VERSION}.pkg\`
          2. Open the package and follow the installer
          3. The agent will start automatically as a LaunchDaemon

          #### Linux (DEB)
          \`\`\`bash
          wget https://github.com/${{ github.repository }}/releases/download/${VERSION}/allow2automate-agent-linux-amd64-${VERSION}.deb
          sudo dpkg -i allow2automate-agent-linux-amd64-${VERSION}.deb
          sudo systemctl start allow2automate-agent
          \`\`\`

          #### Linux (RPM)
          \`\`\`bash
          wget https://github.com/${{ github.repository }}/releases/download/${VERSION}/allow2automate-agent-linux-x86_64-${VERSION}.rpm
          sudo rpm -i allow2automate-agent-linux-x86_64-${VERSION}.rpm
          sudo systemctl start allow2automate-agent
          \`\`\`

          ### Verification

          All installers are signed and include SHA256 checksums in \`checksums.txt\`.

          To verify your download:
          \`\`\`bash
          sha256sum -c checksums.txt
          \`\`\`

          ### Changes

          ${CHANGELOG}

          ### Platform Support

          - Windows 10/11 (x64)
          - macOS 11+ (x64, ARM64)
          - Linux (DEB/RPM, x64)

          ### Requirements

          - Node.js 18.0.0 or higher (bundled in installers)
          - Internet connection for Allow2 API communication

          ---

          **Full Changelog**: https://github.com/${{ github.repository }}/compare/${PREV_TAG}...${VERSION}
          EOF

          cat release-notes.md

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: release-files/*
          body_path: release-notes.md
          draft: false
          prerelease: false
          generate_release_notes: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Release summary
        run: |
          echo "## Release Created Successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Version: ${{ steps.version.outputs.VERSION }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Artifacts" >> $GITHUB_STEP_SUMMARY
          ls -lh release-files/ >> $GITHUB_STEP_SUMMARY
